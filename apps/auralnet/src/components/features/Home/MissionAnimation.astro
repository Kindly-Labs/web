<div id="mission-animation-container" class="relative w-full h-[400px] rounded-xl overflow-hidden cursor-pointer group">
  <canvas id="mission-canvas" class="w-full h-full block"></canvas>
  <div class="absolute bottom-4 right-4 text-white/50 text-xs font-mono opacity-0 group-hover:opacity-100 transition-opacity duration-700">
    Community • Growth • Equity
  </div>
</div>

<script>
  // --- Configuration & Theme ---
  const COLORS = {
    FOREST_GREEN: '#0A2F1F',
    RICH_FOREST: '#1A4D2E',
    SUNSET_ORANGE: '#E8995C',
    LEAF_GREEN: '#7CB342',
    OCEAN_BLUE: '#4A90A4',
    GOLDEN_HOUR: '#F4C430',
    TREE_BARK: '#3D2817',
  };

  const CONFIG = {
    TREE_COUNT: 12,
    CONNECTION_DISTANCE: 150,
    GROWTH_SPEED: 0.05,
    WIND_FACTOR: 0.5,
  };

  // --- Classes ---

  class Tree {
    x: number;
    y: number;
    canvasHeight: number;
    isBig: boolean;
    targetHeight: number;
    currentHeight: number;
    growthProgress: number;
    isGrowing: boolean;
    trunkWidth: number;
    foliageColor: string;
    swayOffset: number;
    sway: number = 0;

    constructor(x: number, y: number, isBig: boolean, canvasHeight: number) {
      this.x = x;
      this.y = y;
      this.canvasHeight = canvasHeight;
      
      // Growth properties
      this.isBig = isBig;
      this.targetHeight = isBig ? 80 + Math.random() * 40 : 80 + Math.random() * 40; // Everyone ends up big
      this.currentHeight = isBig ? this.targetHeight : 20 + Math.random() * 15; // Starts small if not "big"
      this.growthProgress = isBig ? 1 : 0;
      this.isGrowing = isBig; // Big ones are already grown
      
      // Visuals
      this.trunkWidth = 8 + Math.random() * 4;
      this.foliageColor = isBig ? COLORS.RICH_FOREST : COLORS.LEAF_GREEN;
      this.swayOffset = Math.random() * Math.PI * 2;
    }

    update(time: number, windX: number) {
      // Growth Logic: Smoothly interpolate to target height
      if (this.isGrowing && this.currentHeight < this.targetHeight) {
        this.currentHeight += (this.targetHeight - this.currentHeight) * CONFIG.GROWTH_SPEED;
        // As it grows, darken foliage to match established trees
        if (this.currentHeight > this.targetHeight * 0.8) {
            this.foliageColor = COLORS.RICH_FOREST; 
        }
      }

      // Sway Logic
      this.sway = Math.sin(time * 2 + this.swayOffset) * (5 + windX * 10);
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.save();
      ctx.translate(this.x, this.y);

      // Trunk
      ctx.fillStyle = COLORS.TREE_BARK;
      ctx.beginPath();
      ctx.moveTo(-this.trunkWidth / 2, 0);
      ctx.lineTo(this.trunkWidth / 2, 0);
      // Taper trunk slightly
      ctx.lineTo(this.trunkWidth / 4 + this.sway * 0.2, -this.currentHeight);
      ctx.lineTo(-this.trunkWidth / 4 + this.sway * 0.2, -this.currentHeight);
      ctx.closePath();
      ctx.fill();

      // Foliage (Digital/Geometric Style - Triangles)
      ctx.fillStyle = this.foliageColor;
      
      // Draw 3 stacked triangles for foliage
      const levels = 3;
      const levelHeight = this.currentHeight * 0.4;
      
      for (let i = 0; i < levels; i++) {
        const yPos = -this.currentHeight + (i * levelHeight * 0.5);
        const width = (levels - i) * this.trunkWidth * 2.5;
        
        ctx.beginPath();
        ctx.moveTo(0 + this.sway * (0.5 + i * 0.2), yPos - levelHeight); // Top tip
        ctx.lineTo(width / 2 + this.sway * (0.4 + i * 0.1), yPos); // Right bottom
        ctx.lineTo(-width / 2 + this.sway * (0.4 + i * 0.1), yPos); // Left bottom
        ctx.closePath();
        ctx.fill();
      }

      // Glow effect for fully grown trees
      if (this.currentHeight > this.targetHeight * 0.95) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = COLORS.LEAF_GREEN;
        ctx.fillStyle = COLORS.LEAF_GREEN;
        ctx.globalAlpha = 0.1;
        ctx.beginPath();
        ctx.arc(0, -this.currentHeight * 0.6, this.currentHeight * 0.5, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
        ctx.shadowBlur = 0;
      }

      ctx.restore();
    }
  }

  class Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    alpha: number;

    constructor(width: number, height: number) {
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.vx = (Math.random() - 0.5) * 0.5;
      this.vy = (Math.random() - 0.5) * 0.5;
      this.size = Math.random() * 2 + 1;
      this.alpha = Math.random() * 0.5 + 0.2;
    }

    update(width: number, height: number) {
      this.x += this.vx;
      this.y += this.vy;
      if (this.x < 0) this.x = width;
      if (this.x > width) this.x = 0;
      if (this.y < 0) this.y = height;
      if (this.y > height) this.y = 0;
    }

    draw(ctx: CanvasRenderingContext2D) {
      ctx.fillStyle = COLORS.SUNSET_ORANGE;
      ctx.globalAlpha = this.alpha;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1.0;
    }
  }

  // --- Main Logic ---
  
  const initAnimation = () => {
    const container = document.getElementById('mission-animation-container');
    const canvas = document.getElementById('mission-canvas');
    if (!container || !canvas) return;

    const ctx = (canvas as HTMLCanvasElement).getContext('2d');
    if (!ctx) return;
    
    let width: number, height: number;
    let trees: Tree[] = [];
    let particles: Particle[] = [];
    let time = 0;
    let mouse = { x: 0, y: 0 };
    let animationFrameId: number;

    // Resize Handler
    const resize = () => {
      width = container.clientWidth;
      height = container.clientHeight;
      (canvas as HTMLCanvasElement).width = width;
      (canvas as HTMLCanvasElement).height = height; // Standard pixel density for performance/style
      
      initScene();
    };

    // Scene Initialization
    const initScene = () => {
      trees = [];
      particles = [];
      const groundLevel = height * 0.85;

      // Create Particles
      for (let i = 0; i < 30; i++) {
        particles.push(new Particle(width, height));
      }

      // Create Trees
      // Mix of "Big Established" and "Small" trees
      const spacing = width / (CONFIG.TREE_COUNT + 1);
      
      for (let i = 0; i < CONFIG.TREE_COUNT; i++) {
        const x = spacing * (i + 1) + (Math.random() - 0.5) * spacing * 0.5;
        const isBig = i % 3 === 0; // Every 3rd tree is already established
        trees.push(new Tree(x, groundLevel, isBig, height));
      }
    };

    // Interaction
    container.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });

    container.addEventListener('click', () => {
        // Trigger growth for all on click
        trees.forEach(tree => tree.isGrowing = true);
    });

    // Animation Loop
    const animate = () => {
      time += 0.01;
      ctx.clearRect(0, 0, width, height);

      // Background Gradient
      const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
      bgGradient.addColorStop(0, '#051911'); // Darker forest green
      bgGradient.addColorStop(1, COLORS.FOREST_GREEN);
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, width, height);

      // 1. Draw Connections (The "Mycelium/Network" Layer)
      ctx.strokeStyle = COLORS.GOLDEN_HOUR;
      ctx.lineWidth = 1;
      
      // Find trees close to mouse or each other
      trees.forEach((treeA, i) => {
        trees.slice(i + 1).forEach(treeB => {
          const dist = Math.abs(treeA.x - treeB.x);
          
          // Connect if close
          if (dist < CONFIG.CONNECTION_DISTANCE) {
            // Calculate connection strength based on growth
            const strength = (treeA.currentHeight + treeB.currentHeight) / 200;
            ctx.globalAlpha = strength * 0.3;
            
            ctx.beginPath();
            // Curved connection
            ctx.moveTo(treeA.x, treeA.y - treeA.currentHeight * 0.5);
            ctx.quadraticCurveTo(
                (treeA.x + treeB.x) / 2, 
                treeA.y - Math.max(treeA.currentHeight, treeB.currentHeight) * 0.8, 
                treeB.x, 
                treeB.y - treeB.currentHeight * 0.5
            );
            ctx.stroke();

            // If connected to a big tree, small tree starts growing
            if ((treeA.isBig && !treeB.isBig) || (treeB.isBig && !treeA.isBig)) {
               if (Math.random() > 0.98) { // Random chance to start growing
                   if (!treeA.isBig) treeA.isGrowing = true;
                   if (!treeB.isBig) treeB.isGrowing = true;
               }
            }
          }
        });

        // Mouse Interaction: Trigger growth if hovered
        const distToMouse = Math.abs(treeA.x - mouse.x);
        if (distToMouse < 100) {
            treeA.isGrowing = true;
        }
      });
      ctx.globalAlpha = 1.0;

      // 2. Draw Ground
      ctx.fillStyle = '#04140d';
      ctx.beginPath();
      ctx.moveTo(0, height);
      ctx.lineTo(0, height * 0.85);
      // Quadratic bezier for uneven ground
      for (let i = 0; i <= width; i += 50) {
          ctx.lineTo(i, height * 0.85 + Math.sin(i * 0.02) * 10);
      }
      ctx.lineTo(width, height);
      ctx.fill();

      // 3. Draw Trees
      const windX = (mouse.x / width - 0.5) * CONFIG.WIND_FACTOR;
      trees.forEach(tree => {
        tree.update(time, windX);
        tree.draw(ctx);
      });

      // 4. Draw Particles
      particles.forEach(p => {
        p.update(width, height);
        p.draw(ctx);
      });

      animationFrameId = requestAnimationFrame(animate);
    };

    // Start
    resize();
    animate();
    window.addEventListener('resize', resize);

    // Cleanup
    return () => {
        window.removeEventListener('resize', resize);
        cancelAnimationFrame(animationFrameId);
    };
  };

  // Run when Astro navigates or loads
  initAnimation();
  document.addEventListener('astro:page-load', initAnimation);
</script>
